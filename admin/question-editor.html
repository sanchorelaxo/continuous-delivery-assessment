<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Question Editor</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
        }
        .question-editor-container { margin: 2rem auto; }
        .answer-row { display: flex; gap: 0.5rem; margin-bottom: 0.5rem; }
        .answer-row input[type="text"] { flex: 1 1 0; }
        .answer-row .remove-btn { align-self: center; }
        .match-table input[type="text"] { width: 100%; }
        .match-table th, .match-table td { padding: 0.5rem; }
        .match-table .remove-btn { color: #dc3545; cursor: pointer; }
        
        /* Practice area navigation styling */
        .nav-pills .nav-link.active {
            background-color: #0d6efd;
            color: white;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(13, 110, 253, 0.2);
        }
        .nav-pills .nav-link {
            color: #0d6efd;
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            border-radius: 0.25rem;
            transition: all 0.2s ease-in-out;
            border: 1px solid transparent;
        }
        .nav-pills .nav-link:hover {
            background-color: #e7f1ff;
            border-color: #0d6efd20;
        }
        
        /* Question cards styling */
        .question-card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 1.5rem;
            padding: 1.5rem;
            border-left: 5px solid #0d6efd;
        }
        .question-weight {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 0.5rem;
        }
        .weight-1 {
            background-color: #e9ecef;
            color: #495057;
        }
        .weight-2 {
            background-color: #cfe2ff;
            color: #0d6efd;
        }
        .weight-3 {
            background-color: #d1e7dd;
            color: #146c43;
        }
        .action-buttons { white-space: nowrap; }
        .action-buttons .btn { margin-right: 0.25rem; }
        .action-buttons .btn:last-child { margin-right: 0; }
        
        /* Sidebar styling */
        .sidebar-sticky {
            position: sticky;
            top: 1rem;
            max-height: calc(100vh - 2rem);
            overflow-y: auto;
        }
        
        /* No questions message */
        .no-questions {
            text-align: center;
            color: #6c757d;
            font-style: italic;
            padding: 2rem;
        }
        
        /* Strong highlight for selected question */
        #sidebarQuestionsTable .table-active {
            background-color: #0d6efd !important;
            color: white !important;
            border-color: #0d6efd !important;
        }
        
        #sidebarQuestionsTable .table-active td {
            background-color: #0d6efd !important;
            color: white !important;
            border-color: #0d6efd !important;
        }
        
        #sidebarQuestionsTable .table-active .text-danger {
            color: #ffcccc !important;
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <div class="container">
            <a class="navbar-brand" href="../index.html">CD Assessment</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html" id="nav-assessment">Assessment</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html#history" id="nav-history">History</a>
                    </li>
                    <li class="nav-item admin-only d-none">
                        <a class="nav-link" href="../index.html#admin" id="nav-admin">Admin</a>
                    </li>
                    <li class="nav-item admin-only d-none">
                        <a class="nav-link active" href="question-editor.html" id="nav-question-editor">Question Editor</a>
                    </li>
                </ul>
                <!-- Auth dropdown will be inserted here by auth-ui.js -->
            </div>
        </div>
    </nav>

<div class="container-fluid question-editor-container">
    <div class="row">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h1 class="mb-0"><span data-i18n="editorTitle">Question Editor</span> <span class="badge bg-secondary" data-i18n="adminBadge">Admin</span></h1>
                <!-- Language Toggle -->
                <div class="lang-toggle">
                    <button class="btn btn-outline-primary active" onclick="setLanguage('en_CA')" id="lang-en">EN</button>
                    <button class="btn btn-outline-primary ms-2" onclick="setLanguage('fr_CA')" id="lang-fr">FR</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="row">
        <!-- Left Sidebar - Practice Areas -->
        <div class="col-md-3 mb-4">
            <div class="sidebar-sticky">
                <div class="card">
                    <div class="card-header">
                        <span data-i18n="practiceAreas">Practice Areas</span>
                    </div>
                    <div class="card-body p-3">
                        <button class="btn btn-success btn-sm w-100 mb-3" onclick="createNewQuestion()">
                            <i class="fas fa-plus"></i> <span data-i18n="newQuestion">New Question</span>
                        </button>
                        <select class="form-select form-select-sm mb-3" id="practiceAreaFilter" onchange="filterQuestionsBySection(this.value)">
                            <option value="" data-i18n="allAreas">All Areas</option>
                            <option value="buildManagement" data-i18n="buildManagement">Build Management</option>
                            <option value="environments" data-i18n="environments">Environments</option>
                            <option value="releaseManagement" data-i18n="releaseManagement">Release Management</option>
                            <option value="testing" data-i18n="testing">Testing</option>
                            <option value="dataManagement" data-i18n="dataManagement">Data Management</option>
                            <option value="configurationManagement" data-i18n="configurationManagement">Configuration Management</option>
                            <option value="applicationArchitecture" data-i18n="applicationArchitecture">Application Architecture</option>
                            <option value="observability" data-i18n="observability">Observability</option>
                        </select>
                        
                        <!-- Compact Questions Table -->
                        <div class="table-responsive">
                            <table class="table table-sm table-striped" id="sidebarQuestionsTable" style="font-size: 0.7rem;">
                                <thead class="table-dark">
                                    <tr>
                                        <th style="width: 70%;">Question</th>
                                        <th style="width: 20%;">Type</th>
                                        <th style="width: 10%;"></th>
                                    </tr>
                                </thead>
                                <tbody id="sidebarQuestionsBody">
                                    <tr>
                                        <td colspan="3" class="text-center text-muted p-2">Loading...</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Main Content Area -->
        <div class="col-md-9">
            <!-- Question Form -->
            <div class="card mb-4">
                <div class="card-header">
                    <h3 class="mb-0" data-i18n="addEditQuestion">Add/Edit Question</h3>
                </div>
                <div class="card-body">
    <form id="questionForm" autocomplete="off">
        <div class="mb-3">
            <label for="section" class="form-label" data-i18n="section">Section</label>
            <select class="form-select" id="section" required>
                <option value="" data-i18n="selectSection">Select a practice area</option>
                <option value="buildManagement" data-i18n="buildManagement">Build Management</option>
                <option value="environments" data-i18n="environments">Environments</option>
                <option value="releaseManagement" data-i18n="releaseManagement">Release Management</option>
                <option value="testing" data-i18n="testing">Testing</option>
                <option value="dataManagement" data-i18n="dataManagement">Data Management</option>
                <option value="configurationManagement" data-i18n="configurationManagement">Configuration Management</option>
                <option value="applicationArchitecture" data-i18n="applicationArchitecture">Application Architecture</option>
                <option value="observability" data-i18n="observability">Observability</option>
            </select>
        </div>
        <div class="mb-3">
            <label for="type" class="form-label" data-i18n="questionType">Question Type</label>
            <select class="form-select" id="type" required onchange="renderDynamicFields(this.value)">
                <option value="MultipleChoice" data-i18n="multipleChoice">Multiple Choice</option>
                <option value="Checkboxes" data-i18n="checkboxes">Checkboxes</option>
                <option value="MatchAnswers" data-i18n="matchAnswers">Match Answers</option>
                <option value="TrueFalse" data-i18n="trueFalse">True/False</option>
            </select>
        </div>
        <!-- Bilingual Text Fields -->
        <div class="row">
            <div class="col-md-6">
                <div class="mb-3">
                    <label for="text_en" class="form-label" data-i18n="questionTextEn">Question Text (English)</label>
                    <textarea class="form-control" id="text_en" name="text_en" rows="3" required></textarea>
                </div>
                <div class="mb-3">
                    <label for="description_en" class="form-label" data-i18n="descriptionEn">Description (English, optional)</label>
                    <textarea class="form-control" id="description_en" name="description_en" rows="2"></textarea>
                </div>
            </div>
            <div class="col-md-6">
                <div class="mb-3">
                    <label for="text_fr" class="form-label" data-i18n="questionTextFr">Question Text (French)</label>
                    <textarea class="form-control" id="text_fr" name="text_fr" rows="3" required></textarea>
                </div>
                <div class="mb-3">
                    <label for="description_fr" class="form-label" data-i18n="descriptionFr">Description (French, optional)</label>
                    <textarea class="form-control" id="description_fr" name="description_fr" rows="2"></textarea>
                </div>
            </div>
        </div>
        <div class="mb-3">
            <label for="weight" class="form-label" data-i18n="questionWeight">Question Weight</label>
            <select class="form-select" id="weight" required>
                <option value="1" data-i18n="standardWeight">Standard (Normal weight)</option>
                <option value="2" data-i18n="importantWeight">Important (Double weight)</option>
                <option value="3" data-i18n="criticalWeight">Critical (Triple weight)</option>
            </select>
        </div>
        
        <!-- IsUnivocal Checkbox -->
        <div class="mb-3">
            <div class="form-check">
                <input class="form-check-input" type="checkbox" id="isUnivocal" onchange="toggleCorrectAnswerControls()">
                <label class="form-check-label" for="isUnivocal" data-i18n="isUnivocal">
                    Has Correct Answer (Univocal/Closed-ended)
                </label>
                <div class="form-text" data-i18n="isUnivocalHelp">
                    Check this if the question has specific correct answers. Leave unchecked for open-ended questions.
                </div>
            </div>
        </div>
        
        <div id="dynamic-fields"></div>
        <button type="submit" class="btn btn-success" data-i18n="saveQuestion">Save Question</button>
        <button type="button" class="btn btn-secondary ms-2" id="resetBtn" data-i18n="reset">Reset</button>
                </div>
            </div>
            

        </div>
    </div>
</div>
<script>
// Translation object for the question editor
const editorTranslations = {
    en_CA: {
        // Page elements
        editorTitle: "Question Editor",
        adminBadge: "Admin",
        saveQuestion: "Save Question",
        reset: "Reset",
        existingQuestions: "Existing Questions",
        noQuestions: "No questions yet.",
        edit: "Edit",
        delete: "Delete",
        deleteConfirm: "Delete this question?",
        
        // Form labels
        section: "Section",
        selectSection: "Select a practice area",
        questionType: "Question Type",
        questionTextEn: "Question Text (English)",
        descriptionEn: "Description (English, optional)",
        questionTextFr: "Question Text (French)",
        descriptionFr: "Description (French, optional)",
        questionWeight: "Question Weight",
        isUnivocal: "Has Correct Answer (Univocal/Closed-ended)",
        isUnivocalHelp: "Check this if the question has specific correct answers. Leave unchecked for open-ended questions.",
        
        // Section options
        buildManagement: "Build Management",
        environments: "Environments",
        releaseManagement: "Release Management",
        testing: "Testing",
        dataManagement: "Data Management",
        configurationManagement: "Configuration Management",
        applicationArchitecture: "Application Architecture",
        observability: "Observability",
        
        // Question types
        multipleChoice: "Multiple Choice",
        checkboxes: "Checkboxes",
        matchAnswers: "Match Answers",
        trueFalse: "True/False",
        
        // Weight options
        standardWeight: "Standard (Normal weight)",
        importantWeight: "Important (Double weight)",
        criticalWeight: "Critical (Triple weight)",
        
        // Card labels
        sectionLabel: "Section",
        typeLabel: "Type",
        weightLabel: "Weight",
        textLabel: "Text",
        bilingual: "Bilingual",
        enOnly: "EN only",
        frOnly: "FR only",
        actions: "Actions",
        loadingQuestions: "Loading questions...",
        noQuestionsFound: "No questions found.",
        noQuestionsInSection: "No questions in this section.",
        errorLoadingQuestions: "Error loading questions. Please try again.",
        practiceAreas: "Questions by Practice Area",
        allAreas: "All Areas",
        addEditQuestion: "Add/Edit Question",
        newQuestion: "New Question",
        unsavedChangesWarning: "You have unsaved changes. Are you sure you want to leave without saving?",
        
        // Dynamic field labels and placeholders
        options: "Options",
        optionsEn: "Answer Options (English)",
        optionsFr: "Answer Options (French)",
        option: "Option",
        addOption: "Add Option",
        matchPairs: "Match Pairs",
        leftItem: "Left item",
        rightItem: "Right item",
        addPair: "Add Pair",
        correctAnswer: "Correct Answer",
        true: "True",
        false: "False",
        answer: "Answer",
        newAnswer: "New Answer",
        term: "Term",
        match: "Match",
        columnA: "Column A",
        columnB: "Column B",
    },
    fr_CA: {
        // Dynamic field labels and placeholders
        options: "Options",
        optionsEn: "Options de Réponse (Anglais)",
        optionsFr: "Options de Réponse (Français)",
        option: "Option",
        addOption: "Ajouter une Option",
        matchPairs: "Paires Correspondantes",
        leftItem: "Élément gauche",
        rightItem: "Élément droit",
        addPair: "Ajouter une Paire",
        correctAnswer: "Réponse Correcte",
        true: "Vrai",
        false: "Faux",
        answer: "Réponse",
        newAnswer: "Nouvelle Réponse",
        term: "Terme",
        match: "Correspondance",
        columnA: "Colonne A",
        columnB: "Colonne B",
        
        // Page elements
        editorTitle: "Éditeur de Questions",
        adminBadge: "Admin",
        saveQuestion: "Enregistrer la Question",
        reset: "Réinitialiser",
        existingQuestions: "Questions Existantes",
        noQuestions: "Pas encore de questions.",
        edit: "Modifier",
        delete: "Supprimer",
        deleteConfirm: "Supprimer cette question?",
        
        // Form labels
        section: "Section",
        selectSection: "Sélectionnez un domaine de pratique",
        questionType: "Type de Question",
        questionTextEn: "Texte de la Question (Anglais)",
        descriptionEn: "Description (Anglais, facultatif)",
        questionTextFr: "Texte de la Question (Français)",
        descriptionFr: "Description (Français, facultatif)",
        questionWeight: "Poids de la Question",
        isUnivocal: "A une Réponse Correcte (Univoque/Fermée)",
        isUnivocalHelp: "Cochez ceci si la question a des réponses correctes spécifiques. Laissez décoché pour les questions ouvertes.",
        
        // Section options
        buildManagement: "Gestion des Builds",
        environments: "Environnements",
        releaseManagement: "Gestion des Versions",
        testing: "Tests",
        dataManagement: "Gestion des Données",
        configurationManagement: "Gestion de la Configuration",
        applicationArchitecture: "Architecture d'Application",
        observability: "Observabilité",
        
        // Question types
        multipleChoice: "Choix Multiple",
        checkboxes: "Cases à Cocher",
        matchAnswers: "Correspondance de Réponses",
        trueFalse: "Vrai/Faux",
        
        // Weight options
        standardWeight: "Standard (Poids normal)",
        importantWeight: "Important (Double poids)",
        criticalWeight: "Critique (Triple poids)",
        
        // Card labels
        sectionLabel: "Section",
        typeLabel: "Type",
        weightLabel: "Poids",
        textLabel: "Texte",
        bilingual: "Bilingue",
        enOnly: "EN seulement",
        frOnly: "FR seulement",
        actions: "Actions",
        loadingQuestions: "Chargement des questions...",
        noQuestionsFound: "Aucune question trouvée.",
        noQuestionsInSection: "Aucune question dans cette section.",
        errorLoadingQuestions: "Erreur lors du chargement des questions. Veuillez réessayer.",
        practiceAreas: "Questions par Domaine de Pratique",
        allAreas: "Tous les Domaines",
        addEditQuestion: "Ajouter/Modifier une Question",
        newQuestion: "Nouvelle Question",
        unsavedChangesWarning: "Vous avez des modifications non enregistrées. Êtes-vous sûr de vouloir quitter sans enregistrer?"
    }
};

let questions = [];
let allQuestions = [];
let editingIndex = null;
let currentSectionFilter = '';
let currentLanguage = 'en_CA'; // Default language

const form = document.getElementById('questionForm');
const typeSelect = document.getElementById('type');
const dynamicFields = document.getElementById('dynamic-fields');
const resetBtn = document.getElementById('resetBtn');
const langEn = document.getElementById('lang-en');
const langFr = document.getElementById('lang-fr');

// Unsaved changes tracking
let hasUnsavedChanges = false;
let originalFormData = null;

// Function to mark form as changed
function markFormAsChanged() {
    hasUnsavedChanges = true;
}

// Function to mark form as saved
function markFormAsSaved() {
    hasUnsavedChanges = false;
    originalFormData = getFormDataSnapshot();
}

// Function to get a snapshot of current form data for comparison
function getFormDataSnapshot() {
    try {
        return JSON.stringify(getFormData());
    } catch (error) {
        return null;
    }
}

// Function to check if form has unsaved changes
function checkForUnsavedChanges() {
    if (!hasUnsavedChanges) return false;
    
    const currentData = getFormDataSnapshot();
    if (originalFormData && currentData) {
        return originalFormData !== currentData;
    }
    return hasUnsavedChanges;
}

// Function to prompt user about unsaved changes
function promptUnsavedChanges() {
    if (checkForUnsavedChanges()) {
        const message = editorTranslations[currentLanguage].unsavedChangesWarning || 
                       'You have unsaved changes. Are you sure you want to leave without saving?';
        return confirm(message);
    }
    return true;
}
function renderDynamicFields(type, data = {}) {
    dynamicFields.innerHTML = '';
    
    if (type === 'MultipleChoice' || type === 'Checkboxes') {
        // Bilingual Options Header
        const headerDiv = document.createElement('div');
        headerDiv.className = 'row mb-2';
        
        const enCol = document.createElement('div');
        enCol.className = 'col-md-6';
        const enLabel = document.createElement('label');
        enLabel.className = 'form-label';
        enLabel.setAttribute('data-i18n', 'optionsEn');
        enLabel.textContent = editorTranslations[currentLanguage].optionsEn || 'Answer Options (English)';
        enCol.appendChild(enLabel);
        
        const frCol = document.createElement('div');
        frCol.className = 'col-md-6';
        const frLabel = document.createElement('label');
        frLabel.className = 'form-label';
        frLabel.setAttribute('data-i18n', 'optionsFr');
        frLabel.textContent = editorTranslations[currentLanguage].optionsFr || 'Answer Options (French)';
        frCol.appendChild(frLabel);
        
        headerDiv.appendChild(enCol);
        headerDiv.appendChild(frCol);
        dynamicFields.appendChild(headerDiv);
        
        const optionsDiv = document.createElement('div');
        optionsDiv.id = 'optionsDiv';
        dynamicFields.appendChild(optionsDiv);
        
        // Initialize options with bilingual structure
        let options_en = data.options_en || ['', ''];
        let options_fr = data.options_fr || ['', ''];
        let correct = data.correctAnswer || (type === 'Checkboxes' ? [] : 0);
        
        // Ensure both arrays have the same length
        const maxLength = Math.max(options_en.length, options_fr.length, 2);
        while (options_en.length < maxLength) options_en.push('');
        while (options_fr.length < maxLength) options_fr.push('');
        
        function renderOptions(focusIndex = null, focusLang = null) {
            optionsDiv.innerHTML = '';
            
            for (let idx = 0; idx < options_en.length; idx++) {
                const row = document.createElement('div');
                row.className = 'row mb-2 align-items-center';
                
                // English option
                const enCol = document.createElement('div');
                enCol.className = 'col-md-5';
                const inputEn = document.createElement('input');
                inputEn.type = 'text';
                inputEn.className = 'form-control form-control-sm';
                inputEn.value = options_en[idx] || '';
                inputEn.placeholder = idx === options_en.length - 1 ? 'New Option' : 'Option';
                inputEn.dataset.index = idx;
                inputEn.dataset.lang = 'en';
                inputEn.oninput = e => {
                    options_en[idx] = e.target.value;
                    if (idx === options_en.length - 1 && e.target.value) {
                        options_en.push('');
                        options_fr.push('');
                        renderOptions(idx, 'en');
                    }
                };
                enCol.appendChild(inputEn);
                row.appendChild(enCol);
                
                // French option
                const frCol = document.createElement('div');
                frCol.className = 'col-md-5';
                const inputFr = document.createElement('input');
                inputFr.type = 'text';
                inputFr.className = 'form-control form-control-sm';
                inputFr.value = options_fr[idx] || '';
                inputFr.placeholder = idx === options_fr.length - 1 ? 'Nouvelle Option' : 'Option';
                inputFr.dataset.index = idx;
                inputFr.dataset.lang = 'fr';
                inputFr.oninput = e => {
                    options_fr[idx] = e.target.value;
                    if (idx === options_fr.length - 1 && e.target.value) {
                        options_en.push('');
                        options_fr.push('');
                        renderOptions(idx, 'fr');
                    }
                };
                frCol.appendChild(inputFr);
                row.appendChild(frCol);
                
                // Action column (correct answer + delete button)
                const actionCol = document.createElement('div');
                actionCol.className = 'col-md-2 d-flex align-items-center justify-content-center';
                
                // Correct answer control (conditional based on IsUnivocal)
                const isUnivocal = document.getElementById('isUnivocal').checked;
                if (isUnivocal) {
                    const correctDiv = document.createElement('div');
                    correctDiv.className = 'correct-answer-control me-2';
                    
                    if (type === 'Checkboxes') {
                        // Green check emoji (always present, visible when correct)
                        const checkEmoji = document.createElement('span');
                        checkEmoji.textContent = '✅';
                        checkEmoji.style.marginRight = '4px';
                        checkEmoji.style.visibility = (Array.isArray(correct) && correct.includes(idx)) ? 'visible' : 'hidden';
                        checkEmoji.title = 'Correct answer';
                        correctDiv.appendChild(checkEmoji);
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.className = 'form-check-input';
                        checkbox.checked = Array.isArray(correct) && correct.includes(idx);
                        checkbox.title = 'Correct answer';
                        checkbox.onclick = () => {
                            if (!Array.isArray(correct)) correct = [];
                            if (checkbox.checked) {
                                if (!correct.includes(idx)) correct.push(idx);
                            } else {
                                correct = correct.filter(i => i !== idx);
                            }
                            renderOptions(); // Re-render to update check emojis
                        };
                        correctDiv.appendChild(checkbox);
                    } else {
                        // Green check emoji (always present, visible when correct)
                        const checkEmoji = document.createElement('span');
                        checkEmoji.textContent = '✅';
                        checkEmoji.style.marginRight = '4px';
                        checkEmoji.style.visibility = (correct === idx) ? 'visible' : 'hidden';
                        checkEmoji.title = 'Correct answer';
                        correctDiv.appendChild(checkEmoji);
                        
                        const radio = document.createElement('input');
                        radio.type = 'radio';
                        radio.name = 'correctOption';
                        radio.className = 'form-check-input';
                        radio.checked = correct === idx;
                        radio.title = 'Correct answer';
                        radio.onclick = () => { 
                            correct = idx; 
                            renderOptions(); // Re-render to update check emojis
                        };
                        correctDiv.appendChild(radio);
                    }
                    actionCol.appendChild(correctDiv);
                }
                
                // Remove button (show if more than 2 options and not the last empty row)
                const isLastEmptyRow = idx === options_en.length - 1 && 
                                     options_en[idx].trim() === '' && 
                                     options_fr[idx].trim() === '';
                if (options_en.length > 2 && !isLastEmptyRow) {
                    const removeBtn = document.createElement('button');
                    removeBtn.type = 'button';
                    removeBtn.className = 'btn btn-link text-danger p-0';
                    removeBtn.innerHTML = '<i class="fas fa-times"></i>';
                    removeBtn.title = 'Remove option';
                    removeBtn.onclick = () => {
                        options_en.splice(idx, 1);
                        options_fr.splice(idx, 1);
                        // Adjust correct answer indices
                        if (type === 'Checkboxes' && Array.isArray(correct)) {
                            correct = correct.map(i => i > idx ? i - 1 : i).filter(i => i !== idx);
                        } else if (correct > idx) {
                            correct = correct - 1;
                        } else if (correct === idx) {
                            correct = 0;
                        }
                        renderOptions();
                    };
                    actionCol.appendChild(removeBtn);
                }
                
                row.appendChild(actionCol);
                optionsDiv.appendChild(row);
            }
            
            // Restore focus if needed
            if (focusIndex !== null && focusLang !== null) {
                setTimeout(() => {
                    const selector = `input[data-index="${focusIndex}"][data-lang="${focusLang}"]`;
                    const inputToFocus = optionsDiv.querySelector(selector);
                    if (inputToFocus) {
                        inputToFocus.focus();
                        const val = inputToFocus.value;
                        inputToFocus.value = '';
                        inputToFocus.value = val;
                    }
                }, 0);
            }
        }
        
        renderOptions();
        
        // Store the data for form submission
        optionsDiv.getOptionsData = () => {
            return {
                options_en: options_en.filter(opt => opt.trim() !== ''),
                options_fr: options_fr.filter(opt => opt.trim() !== ''),
                correctAnswer: correct
            };
        };
        
        dynamicFields.appendChild(document.createElement('hr'));
    } else if (type === 'MatchAnswers') {
        // Match Answers
        const label = document.createElement('label');
        label.textContent = editorTranslations[currentLanguage].matchPairs || 'Matching Pairs';
        label.className = 'form-label';
        label.setAttribute('data-i18n', 'matchPairs');
        dynamicFields.appendChild(label);
        
        const table = document.createElement('table');
        table.className = 'table table-bordered match-table';
        
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        
        const thA = document.createElement('th');
        thA.setAttribute('data-i18n', 'columnA');
        thA.textContent = editorTranslations[currentLanguage].columnA || 'Column A';
        headerRow.appendChild(thA);
        
        const thB = document.createElement('th');
        thB.setAttribute('data-i18n', 'columnB');
        thB.textContent = editorTranslations[currentLanguage].columnB || 'Column B';
        headerRow.appendChild(thB);
        
        const thEmpty = document.createElement('th');
        headerRow.appendChild(thEmpty);
        
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        const tbody = document.createElement('tbody');
        table.appendChild(tbody);
        
        let pairs = data.pairs || [{left:'',right:''}];
        
        function renderPairs(focusIndex = null, focusSide = null) {
            tbody.innerHTML = '';
            pairs.forEach((pair, idx) => {
                const tr = document.createElement('tr');
                
                const tdA = document.createElement('td');
                const inputA = document.createElement('input');
                inputA.type = 'text';
                inputA.className = 'form-control';
                inputA.value = pair.left;
                inputA.placeholder = editorTranslations[currentLanguage].term || 'Term';
                inputA.dataset.index = idx;
                inputA.dataset.side = 'left';
                inputA.oninput = e => {
                    pairs[idx].left = e.target.value;
                    if (idx === pairs.length-1 && (e.target.value || pairs[idx].right)) {
                        pairs.push({left:'',right:''});
                        renderPairs(idx, 'left');
                    }
                };
                tdA.appendChild(inputA);
                tr.appendChild(tdA);
                
                const tdB = document.createElement('td');
                const inputB = document.createElement('input');
                inputB.type = 'text';
                inputB.className = 'form-control';
                inputB.value = pair.right;
                inputB.placeholder = editorTranslations[currentLanguage].match || 'Match';
                inputB.dataset.index = idx;
                inputB.dataset.side = 'right';
                inputB.oninput = e => {
                    pairs[idx].right = e.target.value;
                    if (idx === pairs.length-1 && (e.target.value || pairs[idx].left)) {
                        pairs.push({left:'',right:''});
                        renderPairs(idx, 'right');
                    }
                };
                tdB.appendChild(inputB);
                tr.appendChild(tdB);
                
                // Remove button
                const tdRemove = document.createElement('td');
                if (pairs.length > 1 && (pair.left || pair.right)) {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'btn btn-sm btn-outline-danger remove-btn';
                    btn.innerHTML = '<i class="fas fa-times"></i>';
                    btn.onclick = () => { pairs.splice(idx,1); renderPairs(); };
                    tdRemove.appendChild(btn);
                }
                tr.appendChild(tdRemove);
                tbody.appendChild(tr);
            });
            
            // Restore focus if needed
            if (focusIndex !== null && focusSide !== null) {
                setTimeout(() => {
                    const inputToFocus = tbody.querySelector(`input[data-index="${focusIndex}"][data-side="${focusSide}"]`);
                    if (inputToFocus) {
                        inputToFocus.focus();
                        // Place cursor at the end of the text
                        const val = inputToFocus.value;
                        inputToFocus.value = '';
                        inputToFocus.value = val;
                    }
                }, 0);
            }
        }
        
        renderPairs();
        dynamicFields.appendChild(table);
        
        // Add button to add new pair
        const addBtn = document.createElement('button');
        addBtn.type = 'button';
        addBtn.className = 'btn btn-sm btn-outline-primary mt-2';
        addBtn.innerHTML = `<i class="fas fa-plus"></i> ${editorTranslations[currentLanguage].addPair || 'Add Pair'}`;
        addBtn.onclick = () => {
            pairs.push({left:'',right:''});
            renderPairs(pairs.length-1, 'left');
        };
        dynamicFields.appendChild(addBtn);
    } else if (type === 'TrueFalse') {
        const container = document.createElement('div');
        container.className = 'mb-3';
        
        // Create the label with translation support
        const label = document.createElement('label');
        label.className = 'form-label';
        label.setAttribute('data-i18n', 'correctAnswer');
        label.textContent = editorTranslations[currentLanguage].correctAnswer || 'Correct Answer';
        
        // Create true option
        const trueDiv = document.createElement('div');
        trueDiv.className = 'form-check d-flex align-items-center';
        
        // Green check emoji for True (conditional based on IsUnivocal)
        const isUnivocal = document.getElementById('isUnivocal').checked;
        if (isUnivocal) {
            const trueCheckEmoji = document.createElement('span');
            trueCheckEmoji.textContent = '✅';
            trueCheckEmoji.style.marginRight = '4px';
            trueCheckEmoji.style.visibility = (data.correctAnswer === 'true' || (!data.correctAnswer && true)) ? 'visible' : 'hidden';
            trueCheckEmoji.title = 'Correct answer';
            trueCheckEmoji.className = 'correct-answer-control';
            trueDiv.appendChild(trueCheckEmoji);
        }
        
        const trueInput = document.createElement('input');
        trueInput.className = 'form-check-input';
        trueInput.type = 'radio';
        trueInput.name = 'trueFalseAnswer';
        trueInput.id = 'answerTrue';
        trueInput.value = 'true';
        trueInput.checked = data.correctAnswer === 'true' || (!data.correctAnswer && true);
        trueInput.onchange = () => {
            if (isUnivocal) {
                // Update emoji visibility
                const trueEmoji = trueDiv.querySelector('.correct-answer-control');
                const falseEmoji = falseDiv.querySelector('.correct-answer-control');
                if (trueEmoji) trueEmoji.style.visibility = 'visible';
                if (falseEmoji) falseEmoji.style.visibility = 'hidden';
            }
        };
        
        const trueLabel = document.createElement('label');
        trueLabel.className = 'form-check-label ms-2';
        trueLabel.htmlFor = 'answerTrue';
        trueLabel.setAttribute('data-i18n', 'true');
        trueLabel.textContent = editorTranslations[currentLanguage].true || 'True';
        
        trueDiv.appendChild(trueInput);
        trueDiv.appendChild(trueLabel);
        
        // Create false option
        const falseDiv = document.createElement('div');
        falseDiv.className = 'form-check d-flex align-items-center';
        
        // Green check emoji for False (conditional based on IsUnivocal)
        if (isUnivocal) {
            const falseCheckEmoji = document.createElement('span');
            falseCheckEmoji.textContent = '✅';
            falseCheckEmoji.style.marginRight = '4px';
            falseCheckEmoji.style.visibility = (data.correctAnswer === 'false') ? 'visible' : 'hidden';
            falseCheckEmoji.title = 'Correct answer';
            falseCheckEmoji.className = 'correct-answer-control';
            falseDiv.appendChild(falseCheckEmoji);
        }
        
        const falseInput = document.createElement('input');
        falseInput.className = 'form-check-input';
        falseInput.type = 'radio';
        falseInput.name = 'trueFalseAnswer';
        falseInput.id = 'answerFalse';
        falseInput.value = 'false';
        falseInput.checked = data.correctAnswer === 'false';
        falseInput.onchange = () => {
            if (isUnivocal) {
                // Update emoji visibility
                const trueEmoji = trueDiv.querySelector('.correct-answer-control');
                const falseEmoji = falseDiv.querySelector('.correct-answer-control');
                if (trueEmoji) trueEmoji.style.visibility = 'hidden';
                if (falseEmoji) falseEmoji.style.visibility = 'visible';
            }
        };
        
        const falseLabel = document.createElement('label');
        falseLabel.className = 'form-check-label ms-2';
        falseLabel.htmlFor = 'answerFalse';
        falseLabel.setAttribute('data-i18n', 'false');
        falseLabel.textContent = editorTranslations[currentLanguage].false || 'False';
        
        falseDiv.appendChild(falseInput);
        falseDiv.appendChild(falseLabel);
        
        // Assemble the container
        container.appendChild(label);
        container.appendChild(trueDiv);
        container.appendChild(falseDiv);
        
        dynamicFields.appendChild(container);
        dynamicFields.appendChild(document.createElement('hr'));
    }
}

typeSelect.onchange = () => {
    markFormAsChanged();
    renderDynamicFields(typeSelect.value);
};

// Add change listeners to all form inputs to track unsaved changes
function addChangeListeners() {
    // Listen to all form inputs
    const formInputs = form.querySelectorAll('input, select, textarea');
    formInputs.forEach(input => {
        input.addEventListener('input', markFormAsChanged);
        input.addEventListener('change', markFormAsChanged);
    });
    
    // Listen to dynamic fields changes (will be called when dynamic fields are rendered)
    const observer = new MutationObserver(() => {
        const dynamicInputs = dynamicFields.querySelectorAll('input, select, textarea');
        dynamicInputs.forEach(input => {
            input.removeEventListener('input', markFormAsChanged); // Prevent duplicates
            input.removeEventListener('change', markFormAsChanged);
            input.addEventListener('input', markFormAsChanged);
            input.addEventListener('change', markFormAsChanged);
        });
    });
    observer.observe(dynamicFields, { childList: true, subtree: true });
}

// Add beforeunload event to warn about unsaved changes
window.addEventListener('beforeunload', (e) => {
    if (checkForUnsavedChanges()) {
        e.preventDefault();
        e.returnValue = ''; // Required for Chrome
        return ''; // Required for other browsers
    }
});

// Initialize change listeners
addChangeListeners();
form.onsubmit = async e => {
    e.preventDefault();
    
    // Gather data
    const data = getFormData();
    
    try {
        let response;
        
        if (editingIndex !== null) {
            // Update existing question
            const question = questions[editingIndex];
            const questionId = question.id || question._id;
            
            response = await fetch(`/api/questions/${questionId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });
            
            if (response.ok) {
                const result = await response.json();
                questions[editingIndex] = result.data;
            } else {
                const errorText = await response.text();
                console.error('Update failed:', response.status, response.statusText, errorText);
                throw new Error(`Failed to update question: ${response.status} ${response.statusText} - ${errorText}`);
            }
            editingIndex = null;
        } else {
            // Create new question - add required ID field
            data.id = `${data.practiceArea}_${Date.now()}`;
            
            response = await fetch('/api/questions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });
            
            if (response.ok) {
                const result = await response.json();
                questions.push(result.data);
            } else {
                const errorText = await response.text();
                console.error('Create failed:', response.status, response.statusText, errorText);
                throw new Error(`Failed to create question: ${response.status} ${response.statusText} - ${errorText}`);
            }
        }
        
        // Update UI on success
        renderSidebarTable();
        form.reset();
        renderDynamicFields(typeSelect.value);
        
        // Clear both language text fields after reset
        document.getElementById('text_en').value = '';
        document.getElementById('description_en').value = '';
        document.getElementById('text_fr').value = '';
        document.getElementById('description_fr').value = '';
        
        // Reset IsUnivocal checkbox to default (false)
        document.getElementById('isUnivocal').checked = false;
        toggleCorrectAnswerControls(); // Update visibility of correct answer controls
        
        // Mark form as saved after successful submission
        markFormAsSaved();
        
    } catch (error) {
        console.error('Error saving question:', error);
        alert('Error saving question: ' + error.message);
    }
};

function getFormData() {
    // Get basic form values
    const section = document.getElementById('section').value || '';
    const type = document.getElementById('type').value || '';
    const weight = parseInt(document.getElementById('weight').value) || 1;
    const textEn = document.getElementById('text_en').value || '';
    const textFr = document.getElementById('text_fr').value || '';
    const descEn = document.getElementById('description_en').value || '';
    const descFr = document.getElementById('description_fr').value || '';
    const isUnivocal = document.getElementById('isUnivocal').checked;
    
    // Format data for backend API (using practiceArea instead of section)
    const data = {
        practiceArea: section,
        type: type,
        weight: weight,
        // Backend expects nested text object
        text: {
            en_CA: textEn,
            fr_CA: textFr
        },
        // Backend expects nested description object
        description: {
            en_CA: descEn,
            fr_CA: descFr
        },
        // IsUnivocal flag
        isUnivocal: isUnivocal,
        // Keep backward compatibility fields
        text_en: textEn,
        text_fr: textFr,
        description_en: descEn,
        description_fr: descFr
    };
    
    if (data.type === 'MultipleChoice' || data.type === 'Checkboxes') {
        // Get bilingual options data from the new structure
        const optionsDiv = document.getElementById('optionsDiv');
        if (optionsDiv && optionsDiv.getOptionsData) {
            const optionsData = optionsDiv.getOptionsData();
            
            // Transform to backend format: array of objects with nested text
            const backendOptions = [];
            const maxLength = Math.max(
                optionsData.options_en ? optionsData.options_en.length : 0,
                optionsData.options_fr ? optionsData.options_fr.length : 0
            );
            
            for (let i = 0; i < maxLength; i++) {
                const enText = optionsData.options_en && optionsData.options_en[i] ? optionsData.options_en[i] : '';
                const frText = optionsData.options_fr && optionsData.options_fr[i] ? optionsData.options_fr[i] : '';
                
                // Only add option if at least one language has text
                if (enText || frText) {
                    backendOptions.push({
                        text: {
                            en_CA: enText,
                            fr_CA: frText
                        },
                        value: i === optionsData.correctAnswer ? 3 : 1 // Correct answer gets value 3, others get 1
                    });
                }
            }
            
            data.options = backendOptions;
            data.correctAnswer = optionsData.correctAnswer;
            
            // Keep backward compatibility fields
            data.options_en = optionsData.options_en;
            data.options_fr = optionsData.options_fr;
        } else {
            // Fallback for old format
            const optionTexts = Array.from(document.querySelectorAll('#optionsDiv input[type="text"]')).map(i=>i.value).filter(Boolean);
            
            // Transform to backend format
            data.options = optionTexts.map((text, index) => ({
                text: {
                    en_CA: text,
                    fr_CA: ''
                },
                value: 1
            }));
            
            if (data.type === 'MultipleChoice') {
                const correctIdx = Array.from(document.querySelectorAll('#optionsDiv input[type="radio"]')).findIndex(i=>i.checked);
                data.correctAnswer = correctIdx >= 0 ? correctIdx : 0;
                // Update the correct option's value
                if (data.options[correctIdx]) {
                    data.options[correctIdx].value = 3;
                }
            } else {
                const correctIndices = Array.from(document.querySelectorAll('#optionsDiv input[type="checkbox"]'))
                    .map((chk, idx) => chk.checked ? idx : -1)
                    .filter(idx => idx >= 0);
                data.correctAnswer = correctIndices;
                // Update correct options' values
                correctIndices.forEach(idx => {
                    if (data.options[idx]) {
                        data.options[idx].value = 3;
                    }
                });
            }
        }
    } else if (data.type === 'MatchAnswers') {
        const pairs = [];
        const leftInputs = document.querySelectorAll('.match-table input[data-side="left"]');
        const rightInputs = document.querySelectorAll('.match-table input[data-side="right"]');
        for (let i = 0; i < leftInputs.length; i++) {
            if (leftInputs[i].value && rightInputs[i].value) {
                pairs.push({
                    left: leftInputs[i].value,
                    right: rightInputs[i].value
                });
            }
        }
        data.pairs = pairs;
    } else if (data.type === 'TrueFalse') {
        const selectedRadio = document.querySelector('input[name="trueFalseAnswer"]:checked');
        data.correctAnswer = selectedRadio ? selectedRadio.value : 'true'; // Default to true if nothing selected
    }
    
    return data;
}
resetBtn.onclick = () => {
    // Check for unsaved changes before resetting
    if (!promptUnsavedChanges()) {
        return; // User cancelled, don't reset
    }
    
    editingIndex = null;
    form.reset();
    document.getElementById('text_en').value = '';
    document.getElementById('description_en').value = '';
    document.getElementById('text_fr').value = '';
    document.getElementById('description_fr').value = '';
    renderDynamicFields(typeSelect.value);
    
    // Clear row selection
    document.querySelectorAll('.question-row').forEach(r => {
        r.classList.remove('table-active');
    });
    
    // Mark form as saved since we just reset
    markFormAsSaved();
};

// Global variables for filtering
// Load questions from MongoDB
async function loadQuestionsFromDB() {
    const tableBody = document.getElementById('sidebarQuestionsBody');
    
    try {
        tableBody.innerHTML = '<tr><td colspan="3" class="text-center text-muted p-2">' + 
                             editorTranslations[currentLanguage].loadingQuestions + '</td></tr>';
        
        const response = await fetch('/api/questions?includeInactive=true');
        if (!response.ok) {
            throw new Error('Failed to fetch questions');
        }
        
        const data = await response.json();
        // API returns questions grouped by practice area, flatten them
        allQuestions = [];
        if (data.success && data.data) {
            Object.values(data.data).forEach(practiceAreaQuestions => {
                allQuestions = allQuestions.concat(practiceAreaQuestions);
            });
        }
        questions = [...allQuestions]; // Copy for editing
        renderSidebarTable();
    } catch (error) {
        console.error('Error loading questions:', error);
        tableBody.innerHTML = '<tr><td colspan="3" class="text-center text-danger p-2">' + 
                             editorTranslations[currentLanguage].errorLoadingQuestions + '</td></tr>';
    }
}

// Filter questions by section
function filterQuestionsBySection(section) {
    currentSectionFilter = section;
    
    // Filter questions based on selected section
    if (section === '') {
        questions = [...allQuestions];
    } else {
        // More robust filtering - check multiple possible field names
        questions = allQuestions.filter(q => {
            return q.practiceArea === section || 
                   q.section === section ||
                   q.practiceArea === section.toLowerCase() ||
                   q.section === section.toLowerCase() ||
                   (q.practiceArea && q.practiceArea.toLowerCase() === section.toLowerCase()) ||
                   (q.section && q.section.toLowerCase() === section.toLowerCase());
        });
        

    }
    
    renderSidebarTable();
}

// Render questions in compact sidebar table format
function renderSidebarTable() {
    const tableBody = document.getElementById('sidebarQuestionsBody');
    tableBody.innerHTML = '';
    
    if (!questions.length) {
        const message = currentSectionFilter ? 
            editorTranslations[currentLanguage].noQuestionsInSection || 'No questions in this section' :
            editorTranslations[currentLanguage].noQuestionsFound || 'No questions found';
        tableBody.innerHTML = `<tr><td colspan="3" class="text-center text-muted p-2">${message}</td></tr>`;
        return;
    }
    
    questions.forEach((q, idx) => {
        const row = document.createElement('tr');
        row.style.cursor = 'pointer';
        row.className = 'question-row';
        
        // Get the appropriate text based on current language
        const questionText = q.text && q.text[currentLanguage] ? q.text[currentLanguage] : 
                           (q.text && q.text.en_CA ? q.text.en_CA : 
                           (q.text_en ? q.text_en : 'No text available'));
        
        // Truncate long text for compact display
        const truncatedText = questionText.length > 30 ? 
                             questionText.substring(0, 30) + '...' : questionText;
        
        // Get type abbreviation
        const typeAbbr = getTypeAbbreviation(q.type);
        
        row.innerHTML = `
            <td title="${questionText}" style="font-size: 0.7rem; padding: 0.25rem;">${truncatedText}</td>
            <td style="font-size: 0.7rem; padding: 0.25rem;">${typeAbbr}</td>
            <td style="font-size: 0.7rem; padding: 0.25rem; text-align: center;">
                <i class="fas fa-times text-danger" onclick="deleteQuestion(${idx}); event.stopPropagation();" style="cursor: pointer; font-size: 0.8rem;" title="Delete question"></i>
            </td>
        `;
        
        // Add click handler for row selection
        row.onclick = () => selectQuestionRow(idx, row);
        
        // Highlight the row if it's currently being edited
        if (editingIndex === idx) {
            row.classList.add('table-active');
        }
        
        tableBody.appendChild(row);
    });
}

// Get type abbreviation for compact display
function getTypeAbbreviation(type) {
    const abbreviations = {
        'MultipleChoice': 'MC',
        'Checkboxes': 'CB',
        'MatchAnswers': 'MA',
        'TrueFalse': 'TF'
    };
    return abbreviations[type] || type.substring(0, 2).toUpperCase();
}

// Create new question function
function createNewQuestion() {
    // Clear the form
    form.reset();
    document.getElementById('text_en').value = '';
    document.getElementById('description_en').value = '';
    document.getElementById('text_fr').value = '';
    document.getElementById('description_fr').value = '';
    
    // Clear editing state
    editingIndex = null;
    
    // Refresh the table to clear highlighting
    renderSidebarTable();
    
    // Reset dynamic fields
    renderDynamicFields(typeSelect.value);
    
    // Focus on the first input
    document.getElementById('section').focus();
}

// Select a question row and populate form
function selectQuestionRow(idx, row) {
    // Check for unsaved changes before switching
    if (!promptUnsavedChanges()) {
        return; // User cancelled, don't switch questions
    }
    
    // Remove previous selection
    document.querySelectorAll('.question-row').forEach(r => {
        r.classList.remove('table-active');
    });
    
    // Highlight selected row
    row.classList.add('table-active');
    
    // Populate form with question data
    const question = questions[idx];
    populateFormWithQuestion(question);
    editingIndex = idx;
    
    // Mark form as saved since we just loaded data
    markFormAsSaved();
}

// Edit question function
function editQuestion(idx) {
    const question = questions[idx];
    populateFormWithQuestion(question);
    editingIndex = idx;
    
    // Highlight the row
    const rows = document.querySelectorAll('.question-row');
    rows.forEach(r => r.classList.remove('table-active'));
    rows[idx].classList.add('table-active');
}

// Delete question function
async function deleteQuestion(idx) {
    if (confirm(editorTranslations[currentLanguage].deleteConfirm)) {
        const questionToDelete = questions[idx];
        const questionId = questionToDelete._id || questionToDelete.id;
        
        try {
            const response = await fetch(`/api/questions/${questionId}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            if (response.ok) {
                // Remove from local arrays on successful API call
                questions.splice(idx, 1);
                // Also remove from allQuestions if it exists there
                if (questionToDelete) {
                    const allIdx = allQuestions.findIndex(q => q._id === questionToDelete._id || q.id === questionToDelete.id);
                    if (allIdx !== -1) {
                        allQuestions.splice(allIdx, 1);
                    }
                }
                renderSidebarTable();
                console.log('Question deleted successfully');
                
                // Clear form if this question was being edited
                if (editingIndex === idx) {
                    form.reset();
                    editingIndex = null;
                }
            } else {
                throw new Error('Failed to delete question');
            }
        } catch (error) {
            console.error('Error deleting question:', error);
            alert('Error deleting question: ' + error.message);
        }
    }
}

// Populate form with question data based on current language
function populateFormWithQuestion(question) {
    // Set basic fields
    document.getElementById('section').value = question.practiceArea || '';
    document.getElementById('type').value = question.type || '';
    document.getElementById('weight').value = question.weight || '';
    
    // Set IsUnivocal checkbox (default to false if not specified)
    document.getElementById('isUnivocal').checked = question.isUnivocal || false;
    
    // Set text fields based on current language
    const textEn = document.getElementById('text_en');
    const textFr = document.getElementById('text_fr');
    const descEn = document.getElementById('description_en');
    const descFr = document.getElementById('description_fr');
    
    if (textEn) textEn.value = question.text?.en_CA || '';
    if (textFr) textFr.value = question.text?.fr_CA || '';
    if (descEn) descEn.value = question.description?.en_CA || '';
    if (descFr) descFr.value = question.description?.fr_CA || '';
    
    // Transform options structure for form rendering
    const transformedQuestion = { ...question };
    
    // Handle bilingual options structure
    if (question.options && Array.isArray(question.options)) {
        // Check if it's the new bilingual format or old MongoDB format
        if (question.options_en && question.options_fr) {
            // New bilingual format
            transformedQuestion.options_en = question.options_en;
            transformedQuestion.options_fr = question.options_fr;
            transformedQuestion.correctAnswer = question.correctAnswer;
        } else if (question.options.length > 0 && typeof question.options[0] === 'object' && question.options[0].text) {
            // Old MongoDB format with text objects
            transformedQuestion.options_en = question.options.map(option => {
                if (option.text && typeof option.text === 'object') {
                    return option.text.en_CA || option.text[currentLanguage] || '';
                }
                return option.text || option || '';
            });
            transformedQuestion.options_fr = question.options.map(option => {
                if (option.text && typeof option.text === 'object') {
                    return option.text.fr_CA || '';
                }
                return ''; // No French text in old format
            });
            
            // Handle correct answer - find the option with the highest value
            if (question.options.length > 0) {
                const correctOption = question.options.reduce((max, option) => 
                    (option.value > max.value) ? option : max
                );
                const correctIndex = question.options.indexOf(correctOption);
                transformedQuestion.correctAnswer = correctIndex >= 0 ? correctIndex : 0;
            }
        } else {
            // Simple array format (old single-language)
            transformedQuestion.options_en = question.options.map(opt => opt || '');
            transformedQuestion.options_fr = question.options.map(() => ''); // Empty French options
            transformedQuestion.correctAnswer = question.correctAnswer || 0;
        }
    } else if (question.options_en || question.options_fr) {
        // Direct bilingual format
        transformedQuestion.options_en = question.options_en || [];
        transformedQuestion.options_fr = question.options_fr || [];
        transformedQuestion.correctAnswer = question.correctAnswer;
    }
    
    // Render dynamic fields for the question type
    renderDynamicFields(question.type, transformedQuestion);
    
    // Mark form as saved since we just loaded data
    markFormAsSaved();
}
// Function to toggle correct answer controls based on IsUnivocal checkbox
function toggleCorrectAnswerControls() {
    const isUnivocal = document.getElementById('isUnivocal').checked;
    const typeSelect = document.getElementById('type');
    
    // For Multiple Choice and Checkboxes, preserve current options data and re-render
    if (typeSelect.value === 'MultipleChoice' || typeSelect.value === 'Checkboxes') {
        const optionsDiv = document.getElementById('optionsDiv');
        if (optionsDiv && optionsDiv.getOptionsData) {
            // Get current options data to preserve content
            const currentOptionsData = optionsDiv.getOptionsData();
            // Re-render with preserved data
            renderDynamicFields(typeSelect.value, currentOptionsData);
        } else if (typeSelect.value) {
            // Fallback: re-render with empty data if no existing data
            renderDynamicFields(typeSelect.value, {});
        }
    }
    // For TrueFalse, preserve current selection and re-render
    else if (typeSelect.value === 'TrueFalse') {
        const selectedRadio = document.querySelector('input[name="trueFalseAnswer"]:checked');
        const currentData = {
            correctAnswer: selectedRadio ? selectedRadio.value : 'true'
        };
        renderDynamicFields(typeSelect.value, currentData);
    }
    // For other types, just toggle visibility of existing controls
    else {
        const correctAnswerElements = document.querySelectorAll('.correct-answer-control');
        correctAnswerElements.forEach(element => {
            element.style.display = isUnivocal ? 'block' : 'none';
        });
    }
}

// Language toggle function
function setLanguage(lang) {
    currentLanguage = lang;
    
    // Update active button styles
    document.querySelectorAll('.lang-toggle .btn').forEach(btn => {
        btn.classList.toggle('active', btn.getAttribute('onclick').includes(lang));
    });
    
    // Both language fields are always visible, both are required
    // No need to hide/show content or change required attributes
    
    // Update all translations (labels and interface text)
    updateTranslations();
    
    // If currently editing a question, only refresh the dynamic field labels
    // without repopulating form values to preserve user changes
    if (editingIndex !== null && questions[editingIndex]) {
        const currentType = document.getElementById('type').value;
        if (currentType) {
            // Only update the labels in dynamic fields, preserve all form values
            refreshDynamicFieldLabels(currentType);
        }
    }
    
    // Refresh questions table with new language
    renderSidebarTable();
}

// Function to refresh only the labels in dynamic fields without changing form values
function refreshDynamicFieldLabels(type) {
    const translations = editorTranslations[currentLanguage];
    if (!translations) return;
    
    // Update labels for different question types
    if (type === 'MultipleChoice' || type === 'Checkboxes') {
        // Update options header label
        const optionsHeader = document.querySelector('#dynamic-fields .row.mb-2 .col-6:first-child h6');
        if (optionsHeader) {
            optionsHeader.textContent = translations.options + ' (EN)';
        }
        
        const optionsHeaderFr = document.querySelector('#dynamic-fields .row.mb-2 .col-6:last-child h6');
        if (optionsHeaderFr) {
            optionsHeaderFr.textContent = translations.options + ' (FR)';
        }
        
        // Update option placeholders
        const optionInputsEn = document.querySelectorAll('#dynamic-fields input[placeholder*="Option"][placeholder*="EN"]');
        optionInputsEn.forEach((input, index) => {
            input.placeholder = `${translations.option} ${index + 1} (EN)`;
        });
        
        const optionInputsFr = document.querySelectorAll('#dynamic-fields input[placeholder*="Option"][placeholder*="FR"]');
        optionInputsFr.forEach((input, index) => {
            input.placeholder = `${translations.option} ${index + 1} (FR)`;
        });
        
        // Update correct answer label if visible
        const correctAnswerLabel = document.querySelector('#dynamic-fields .form-label');
        if (correctAnswerLabel && correctAnswerLabel.textContent.includes('Correct Answer')) {
            correctAnswerLabel.textContent = translations.correctAnswer;
        }
        
    } else if (type === 'TrueFalse') {
        // Update True/False labels
        const trueLabels = document.querySelectorAll('#dynamic-fields label[for*="true"]');
        trueLabels.forEach(label => {
            if (label.textContent.includes('True')) {
                label.textContent = label.textContent.replace(/True.*/, translations.trueLabel);
            }
        });
        
        const falseLabels = document.querySelectorAll('#dynamic-fields label[for*="false"]');
        falseLabels.forEach(label => {
            if (label.textContent.includes('False')) {
                label.textContent = label.textContent.replace(/False.*/, translations.falseLabel);
            }
        });
        
        // Update correct answer label if visible
        const correctAnswerLabel = document.querySelector('#dynamic-fields .form-label');
        if (correctAnswerLabel && correctAnswerLabel.textContent.includes('Correct Answer')) {
            correctAnswerLabel.textContent = translations.correctAnswer;
        }
        
    } else if (type === 'MatchAnswers') {
        // Update match pairs labels
        const pairsHeader = document.querySelector('#dynamic-fields h6');
        if (pairsHeader && pairsHeader.textContent.includes('Match Pairs')) {
            pairsHeader.textContent = translations.matchPairs || 'Match Pairs';
        }
        
        // Update pair input placeholders
        const pairInputsEn = document.querySelectorAll('#dynamic-fields input[placeholder*="Item"][placeholder*="EN"]');
        pairInputsEn.forEach((input, index) => {
            const pairNum = Math.floor(index / 2) + 1;
            const itemType = index % 2 === 0 ? 'A' : 'B';
            input.placeholder = `${translations.item || 'Item'} ${pairNum}${itemType} (EN)`;
        });
        
        const pairInputsFr = document.querySelectorAll('#dynamic-fields input[placeholder*="Item"][placeholder*="FR"]');
        pairInputsFr.forEach((input, index) => {
            const pairNum = Math.floor(index / 2) + 1;
            const itemType = index % 2 === 0 ? 'A' : 'B';
            input.placeholder = `${translations.item || 'Item'} ${pairNum}${itemType} (FR)`;
        });
    }
}

// Helper function to load language content when editing
function loadLanguageContent(question) {
    // Load English content
    document.getElementById('text_en').value = question.text_en || '';
    document.getElementById('description_en').value = question.description_en || '';
    
    // Load French content
    document.getElementById('text_fr').value = question.text_fr || '';
    document.getElementById('description_fr').value = question.description_fr || '';
}

// Function to update all translatable elements
function updateTranslations() {
    const translations = editorTranslations[currentLanguage];
    if (!translations) return;
    
    // Update all elements with data-i18n attribute
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (translations[key]) {
            // For inputs with value attribute
            if (el.tagName === 'INPUT' && el.type !== 'submit' && el.type !== 'button') {
                el.value = translations[key];
            }
            // For option elements
            else if (el.tagName === 'OPTION') {
                el.textContent = translations[key];
            }
            // For buttons
            else if (el.tagName === 'BUTTON' || el.type === 'submit' || el.type === 'button') {
                // If button has an icon, preserve it
                if (el.innerHTML.includes('<i class="fas')) {
                    const iconMatch = el.innerHTML.match(/<i class="fas[^>]+><\/i>/i);
                    if (iconMatch) {
                        el.innerHTML = `${iconMatch[0]} ${translations[key]}`;
                        return; // Use return instead of continue since we're in a forEach callback
                    }
                }
                el.textContent = translations[key];
            }
            // For all other elements
            else {
                el.textContent = translations[key];
            }
        }
    });
}

// Initialize
renderDynamicFields(typeSelect.value);
setLanguage('en_CA'); // This will also call renderQuestionsTable()
// Load questions from MongoDB on page load
loadQuestionsFromDB();
</script>

<!-- Bootstrap JS -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<!-- Authentication and Navigation Scripts -->
<script src="../js/auth/auth-service.js"></script>
<script src="../js/auth/auth-ui.js"></script>

<script>
// Initialize authentication and show admin-only navigation items
document.addEventListener('DOMContentLoaded', function() {
    // Wait a bit for auth scripts to load, then initialize
    setTimeout(function() {
        try {
            // Check if auth service is available and has init method
            if (window.authService && typeof window.authService.init === 'function') {
                window.authService.init();
                
                // Show admin-only navigation items if user is admin
                if (window.authService.isAuthenticated() && window.authService.isAdmin()) {
                    document.querySelectorAll('.admin-only').forEach(item => {
                        item.classList.remove('d-none');
                    });
                }
            } else {
                console.log('Auth service not available - showing admin navigation for development');
                // Show admin items for development/testing when auth service is not available
                document.querySelectorAll('.admin-only').forEach(item => {
                    item.classList.remove('d-none');
                });
            }
        } catch (error) {
            console.error('Error initializing auth service:', error);
        }
    }, 100);
});
</script>

</body>
</html>
